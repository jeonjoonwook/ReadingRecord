프로토타입과 스코프

기본적으로 스프링 빈은 싱글톤
하나의 빈 오브젝트에 여러 스레드가 접근하기 때문에 상태 값을 인스턴스 변수에 저장해두면 안됨
싱글톤 필드에는 의존관계에 있는 빈에 대한 레퍼런스나 읽기전용 값만 저장

여러개의 오브젝트를 만들어야 할 때가 있음 
 -> 프로토타입 빈과 스코프 빈이 있음

스코프 : 존재할 수 있는 범위 , 빈의 스코프는 빈 오브젝트가 만들어져 존재할 수 있는 범위
단일 컨테이너 구조에서는 컨테이너가 존재하는 범위와 싱글톤이 존재하는 범위가 일치
request 스코프는 하나의 요청이 끝날 때까지만 존재

프로토타입 빈은 컨테이너에 빈을 요청할 때마다 새로운 오브젝트를 만든다.

IoC의 기본개념은 모든 오브젝트의 생명주기를 컨테이너가 관리함, 
그런데 프로토타입 스코프를 갖는 빈은 요청이 있을 때마다 컨테이너가 생성하고 초기화하고 DI까지 해주기도 하지만 
빈을 제공하고 나면 컨테이너는 더 이상 빈 오브젝트를 관리하지 않음
프로토타입 빈 오브젝트의 관리는 전적으로 DI받은 오브젝트에 달려 있음 => 주입 받은 오브젝트에 종속

용도
코드에서 new로 오브젝트를 생성하는 것을 대신하기 위해 사용
대부분의 경우 new로 오브젝트를 생성하거나 팩토리를 이용해 오브젝트를 생성하면 됨, 하지만 컨테이너의 DI 기능을 사용해야 하고 싶은 경우 프로토타입 빈 사용
매번 새로운 오브젝트가 필요하면서 DI를 통해 다른 빈을 사용해야할 경우 프로토 타입 빈이 적절

의존관계를 외부에서 주입받는게 아니라 직접 필요한 의존관계를 찾는 것을 Dependency Lookup 의존관계 조회라고 함

프로토타입 빈의 DL 전략
프로토타입 빈은 DL 방식을 사용해 매번 컨테이너에 빈을 요청해서 새로운 오브젝트를 받아서 사용해야 한다.
가장 간단한 방법은 ApplicationContext를 DI 받아둔 뒤에 코드에서 getBean메소드를 직접 호출
- 스프링 컨텍스트 전체를 주입받게 되면, 스프링 컨테이너에 종속족인 코드가 되고 단위 테스트가 어려워 짐

ObjectFactory
 ApplicationContext를 Di 받아서 getBean()을 호출해 원하는 프로토타입 빈을 가져오는 방식으로 동작하는 팩토리를 하나 만들어서
빈으로 등록해두고, 이 팩토리를 Di 받아서 필요할 때 getObject와 같은 메소드를 호출
 스프링이 제공하는 인터페이스로 ApplicationContext를 직접 사용하는 것보다 훨씬 깔끔

메소드 주입 : 메소드를 통해 DI 받는게 아니라 메소드 코드 자체를 주입하는 것을 말함, 새로운 프로토타입 빈을 가져오는 기능을 담당하는 메소드를 런타임시에 추가

Provider<T> : ObjectFactory와 거의 유사

스코프
스프링은 싱글톤 프로토타입 외에 요청, 세션, 글로벌 세션, 애플리케이션 스코프를 제공함

요청 스코프
하나의 웹 요청 안에서 만들어지고 해당 요청이 끝날때 제거된다.
각 요청별로 독립적인 빈이 만들어지기 때문에 빈 오브젝트에 상태값을 저장해도 된다.
요청 스코프 빈의 주요 용도는 애플리케이션 코드에서 생성한 정보를 프레임워크 레벨의 서비스나 인터셉터 등에 전달하는 것이다.

세션스코프
HTTP 세션과 같은 존재 범위를 갖는 빈으로 만들어주는 스코프다.
HTTP 세션은 사용자별로 만들어지고 브라우저를 닫거나 세션 타임이 종료될 때까지 유지되기 때문에 로그인 정보나 사용자별 선택옵션 등을 저장해두기에 유용하다.
세션 스코프를 이용하면 HTTP 세션에 저장되는 정보를 모든 계층에서 안전하게 이용할 수 있다. 웹 페이지가 바뀌고 여러 요청을 거치는 동안에도 세션 스코프 빈은 계속 유지

애플리케이션 스코프
싱글톤 스코프와 비슷한 존재 범위를 갖는다.

스코프 빈의 사용방법
 애플리케이션 스코프를 제외한 나머지는 하나 이상의 오브젝트가 만들어져야 하기 때문에 싱글톤에 DI 해주는 방법으론 사용할 수 없다.
스코프 빈은 프로토타입 빈과 마찬가지로 Provider나 ObjectFactoryt 같은 DL 방식으로 사용해야 한다.
스코프 빈은 싱글톤에서 일반적인 방법으로 DI 하는것은 불가능하다. 대신 직접 스코프 빈을 DI하지 않고 스코프 빈에 대한 프록시를 DI해주는 방식이 있다. 그러면 마치 평범한 싱글톤 빈을 이용하듯이 스코프 빈을 쓸 수 있다.
@Scope 애노테이션의 proxyMode 엘리먼트를 사용해서 프록시 모드를 결정한다.
클라이언트는 스코프 프록시 오브젝트를 실제 스코프 빈처럼 사용하면 프록시에서 현재 스코프에 맞는 실제 빈 오브젝트로 작업을 위임해준다.
스코프 프록시는 각 요청에 연결된 세션 정보를 참고해서 사용자마다 다른 오브젝트를 사용하게 해준다.
프록시 방식의 DI를 적용하면 스코프 빈이지만 마치 싱글톤 빈을 사용하듯이 편하게 쓸 수 있다는 장점이 있다. 