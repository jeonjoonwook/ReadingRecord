3.1 다시보는 초난감 DAO

db 풀은 getConnection으로 가져간 커넥션을 명시적으로 close 해줘야 함

try-catch-finally문을 써서 어떤 상황에서도 리소스를 반환해야 한다.

하지만 dao 코드는 문제가 있다.

trcy catch finally 블록이 2중으로 중첩까지 되고 모든 메소드마다 반복

우선 코드에서 변하는 부분과 변하지 않는 부분을 구분해야 한다.

첫번째 방법은 변하는 부분을 메소드로 빼는것이다. 코드에선 preparedStatement(쿼리)

보통 메소드 추출 리팩토링은 분리시킨 메소드를 다른곳에서 재사용할 수 있어야 하는데

반대로 분리시키고 남은 try catch finally 부분이 재사용이 필요한 부분이다.

템플릿 메소드 패턴의 적용

변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상메소드로 정의해둬서
서브클래스에서 오버라이드하여 새롭게 정의해 쓰도록 하는것

makeStatement()를 추상 메소드로 선언하고 이를 상속하는 서브클래스를 만들어
이 메소드를 구현한다.

기능을 확장하고 싶을때마다 상속을 통해 확장 가능하고 상위 DAO 클래스에 불필요한
변화는 생기지 않도록 할수 있다.

문제는 로직마다 상속을 통해 새로운 클래스를 만들어야 한다.
또 확장구조가 이미 클래스를 설계하는 시점에서 고정되어 버림
userdao의 try/catch/finally 블록과 변하는 preparedStatement를 담고 있는
서브 클래스들이 컴파일 시점에 이미 관계가 결정됨

전략 패턴의 적용
오브젝트를 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록하기
contextMethod가 바뀌지 않는 코드이고
인터페이스를 상속해 구현한 부분은 변하는 부분이다.
어떤 전략을 쓸지는 client에서 결정하도록 한다.

문제
DAO 메소드마다 새로운 StatementStrategy 구현 클래스를 만들어야 한다.
이렇게 되면 기존 UserDao 때보다 클래스 파일의 개수가 늘어남
또한 Dao에서 StatementStrategy에 전달할 부가 정보가 있는 경우
생성자와 인스턴스 변수를 만들어야 함

해결
StatementStrategy 전략 클래스를 매번 독립된 파일로 만들지 말고
UserDao 클래스 안에 내부 클래스로 정의하기
내부 클래스를 이용하면 user와 같은 정보 전달 받기 위해 만들었던 생성자와 인스턴스 변수
제거 가능하므로 간결하짐

익명 내부 클래스를 만드는것도 방법이다.



