2장 테스트

2.1 UserDaoTest 다시보기

UserDaoTest에서는 main메소드에서 userDao 오브젝트를 가져와 메소드 호출한다.

보통 웹 테스트를 많이 사용함. 직접 값을 입력해보거나 클릭하거나 등등..

그런데 이 방법은 DAO에 대한 테스트로 문제가 많다. DAO뿐만 아니라 서비스 클래스, 컨트롤러, JSP, 뷰 등이 만들어져 있어야 테스트 가능 테스트 중에 에러가 나면 어디서 에러가 났는지 찾기 힘들다.

테스트 하고자 하는 대상을 명확히 하고 그 대상에만 집중해서 테스트 하는 것이 바람직 userDao로 테스트 하면 JSP나 Servlet을 볼 필요가 없다.

#단위 테스트 : 작은 단위의 코드에 대해 테스트 수행하는 것 일반적으로 단위는 작을수록 좋음

때로는 로그인 부터 로그아웃까지 전과정을 테스트 해야 하는 경우도 있지만 단위테스트가 우선이다.

자동화된 테스트의 장점은 자주 반복할 수 있음 한줄의 코드만 건드려도 전체에 영향을 줄수가 있음... 그래서 자동화된 테스트는 꼭 필요

UserDaoTest의 문제점

자동화된 테스트를 하긴 했지만 콘솔에 값만 출력한것 가지고 성공적으로 수행되었는지 사람이 판단해야함
테스트용 main메소드가 수십 수백개가 있으면 매번 실행하기에 번거로움..
2.2 UserDaoTest 개선 지금까지는 결과를 사람의 눈으로 확인하도록 단순히 콘솔에만 출력했는데, 이번에틑 테스트 결과를 직접 확인하고 기대한 결과와 다를 경우 "테스트 실패" 라고 처리한다.

main메소드에 있던 테스트 코드들을 JUnit으로 옮긴다. @Test를 써서 Junit에게 테스트용 메소드임을 알려주고 메소드에는 public으로 선언한다. assertThat을 이용해서 첫번째 파라미터와 두번째 파라미터와의 값을 비교하여 테스트 성공 유무를 판단한다.

2.3 개발자를 위한 테스팅 프레임워크 JUnit

Junit 프레임워크를 사용하여 테스트를 자동화 한다.

성공하는 테스트만 골라서 하지 말고 실패하는 케이스도 잘 작성 하자.

#테스트 주도 개발 : 만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법

테스트 코드를 미리 만들면 추후 생길 수 있는 거대한 에러를 초기에 잡을 수 있다.

@Before 테스트를 실행할 때마다 반복되는 준비 작업을 별도의 메소드에 넣어주고 이를 매번 @Test 메소드를 실행하기 전에 먼저 실행 시켜 준다.

@After는 @Test 가 끝난후 실행되게 한다.

테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다. 테스트 클래스가 @Test 메소드를 두개 갖고 있다면 테스트가 실행되는 중에 JUnit은 오브젝트를 두번 만들것이다. 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위함이다.

#픽스쳐 : 테스트를 수행하는 데 필요한 정보를 픽스처라고 함. 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 @Before로 생성해 두면 편리함

2.4 스프링 테스트 적용

@Before 메소드가 테스트 메소드 개수만큼 반복되기 때문에 어플리케이션 컨텍스트도 세번 만들어지는 문제 발생
어플리케이션 컨텍스트는 생성에 많은 시간과 자원 소모

@Runwith을 쓰면 junit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리
@ContextConfiguration은 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치 지정

이렇게 하면 한번의 어플리케이션 컨텍스트가 만들어지고 테스트 할때마다 공유하게 되어 테스트 시간이 줄어듬

@Autowired를 사용하면 컨텍스트의 빈을 테스트 오브젝트에 DI할 수 있다.

기술의 사용 방법을 익히고 이해를 돕기 위해 학습 테스트를 작성하자.

오류가 발견될 경우 그에 대한 버그 테스트를 만들어 두면 유용하다.



