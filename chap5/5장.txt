5장 서비스 추상화

이제 비즈니스 로직을 추가하고 싶음..

5.1 사용자 레벨 관리 기능 추가

사용자 관리 시스템에 레벨 기능 추가

final static int BASIC = 1 과 같은 형식으로 해도 될것 같지만 안전하지 않음
엄한 숫자가 들어 올수도 있기 때문..

대신 ENUM을 사용한다. 
DB에는 이늄타입은 없으니까 넣을때는 이늄을 숫자로 바꾸고 DB에서 받아올 때는
숫자에서 이늄으로 변환 시킨다.

UserDao를 사용하는 UserService를 만들어서 사용자 등급 갱신 같은 비즈니스 로직은
UserService에서 처리한다.

사용자 등급 변경기능을 처음에는 USerService안에서 다 구현하고, SRP에 의해
User, Level, UserDao, UserService등으로 나눈다. 
이렇게 하면 수정할때 고쳐야 할 부분이 명확히 파악이 되고 응집도 높은 프로그래밍이 가능해짐

객체지향적인 코드는 다른 오브젝트의 데이터를 가져와서 작업하는 대신 데이터를
갖고 있는 다른 오브젝트에게 작업을 해달라고 요청한다. 

.2 트랜잭션 서비스 추상화

100명의 사용자가 업데이트를 하는데 중간에 몇명이서 예외가 발생하여 작업을 완료 할 수 없을때
초기단계로 돌려놓아야 한다.

트랜잭션이란 더 이상 나눌 수 없는 단위의 작업을 말한다.

첫번째 SQL이 성공적으로 성공했더라도 두번째 SQL이 실패하면 첫번째 SQL도 취소해야 한다.
이런 취소 작업을 트랜잭션 롤백이라고 한다.

반대로 모든 SQL을 성공적으로 실행되면 DB에 알려줘서 작업을 확정해야 한다.
이것을 트랜잭션 커밋이라고 한다.

애플리케이션 내에서 트랜잭션이 시작되고 끝나는 위치를 트랜잭션의 경계라고 부른다.

트랜잭션 동기화
스프링이 제공하는 방법으로 어떤 서비스 로직에서 트랜잭션을 시작하기 위해  만든
Connection 오브젝트를 특별한 저장소에 보관해 두고, 이후에 호출되는 로직에서
Connection을 가져다가 사용함

ThreadLocal에 connection이 저장되고 작업 쓰레드마다 독립적으로 Connection오브젝트를
저장하고 관리하기 때문에 다중 사용자를 처리하는 멀티스레드 환경에서 충돌이 날 염려가 없다.
또한 Connection 변수를 물고 다닐 필요가 없음

또 다른 문제는 Hibernate, JPA 등 사용 기술에 따라 코드가 달라지는데
스프링은 이를 위해 트랜잭션 서비스 추상화를 해둠, PlatformTransactionManager를 사용하면
데이터 엑세스 기술에 상관없이 일관된 방식으로 트랜잭션 관리 가능하다.

JDBC는 DB 연동/sql 사용을 추상화 한 것이라면, PlatformTransactionManager는 데이터 엑세스 기술의
트랜잭션 경계 설정을 추상화 한것

서비스 추상화와 단일 책임 원칙
단일 책임 원칙은 하나의 모듈은 한 가지 책임을 가져야 한다는 것을 의미 , 하나의 모듈이
바뀌는 이유는 한가지여야 한다.

단일 책임 원칙의 장점
어떤 변경이 필요할때 수정 대상이 명확해짐
결합도가 낮아져 서로의 변경이 영향을 주지 않음

단일 책임 원칙을 잘 지키는 코드를 만들려면 인터페이스를 도입하고 이를 DI로 연결해야 한다.

DI가 없다면 결국 코드사이의 결합이 남아 있게 됨 (new 를 사용해 구체적인 의존 클래스를 지정해야 하므로)

