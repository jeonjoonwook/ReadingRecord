1장 오브젝트와 의존관계

객체 지향 프로그래밍 : 스프링의 가장 중요한 가치

오브젝트의 생성부터 소멸, 설계에 가장 큰 관심

1.1 초난감 DAO

#DAO : DB를 사용해 데이터를 조회하거나 조작하도록 만든 오브젝트

#자바빈 : 디폴트 생성자와 프로퍼티(속성)을 가지고 만들어진 오브젝트

userDAO 클래스를 만들고 JDBC 연동을해 main 메소드에서 실행한다.

기능은 정상적으로 작동하지만 문제가 많은 코드이다.

1.2 DAO의 분리

객체 지향 세계에서 오브젝트의 설계와 이를 구현한 코드는 계속 변한다.

미래의 변화에 대한 부담을 최소화 할수 있는 코드를짜야함

관심사의 분리 : 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 따로 떨어져서 서로 영향을 주지 않도록 분리

예제에서는 userDao의 커넥션을 가져오는 부분을 getConnection 메소드로 분리

기능에는 변함 없지만 깔끔한 코드를 만듬 : 리팩토링

공통의 기능을 담당하는 메소드로 중복된 코드 추출 : 메소드 추출 기법

userDao 소스코드를 고객에 제공 안하고 고객 스스로 DB커넥션 방식 적용하는법
=> getConnection()을 추상 메소드로 만든다.
추상 메소드는 메소드는 없지만 메소드 자체는 존재

고객은 UserDao를 상속받아서  NUserDao라는 서브 클래스를 만들고 추상메소드로 선언했던 getConnection()메소드를 원하는 방식으로 구현

템플릿 메소드 패턴 : 슈퍼클래스에 기본적인 로직의 흐름을 만들고 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든뒤 서브 클래스에서 이런 메소드를 필요에 맞게 구현해서 사용

팩토리 메소드 패턴 : 서브 클래스에서 구체적인 오브젝트 생성 방법을 결정한다. 변하지 않는 기능은 슈퍼클래스에 만들어 두고 자주 변경되어 확장할 기능은 서브 크래스에 만들어서 사용

ex) 서브 클래스에서 구현하는 getConnection()메소드는 JDBC가 정의한 Connection인터페이스를 구현한 Connection오브젝트를 각자의 생성 알고리즘을 이용해
만들어 낸다. UserDao는 Connection 인터페이스에 정의된 메소드를 사용할 뿐 이다.

#디자인 패턴
디자인 패턴은 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션

템플릿 메소드 패턴, 팩토리 메소드 패턴은 코드를 분리해 내는데 효과적
but 상속을 사용했다는 단점 : UserDao가 이미 다른 상속을 받고 있다면?, 상위 클래스가 바뀌면 하위 클래스도 바꿔야함

1.3 DAO의 확장
클래스의 분리 : 상속 관계가 아닌 완전히 독립적인 클래스로 만든다 => DB커넥션과 관련된 부분을 별도의 클래스에 담고 이렇게 만든 클래스를 UserDao가 new SimpleConnectionMaker로 생성한후 이용한다.

문제점1
N사와 D사에 상속을 통해 DB커넥션 기능을 확장해서 사용하게 했던게 불가능해짐... userDao코드가 SimpleConnectionMaker에 종속되어 있기 때문

문제점2
DB커넥션을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으로 알고 있어야 함, N사에서 다른 클래스를 구현하면 어쩔수 없이 userdao수정해야 함

해결책 : 인터페이스를 이용하자!
ConnectionMaker 인터페이스를 만들고 NConnectionMaker, DConnectionMaker에서 구체화 하자.

하지만 여전히 connectMaker = new DConnectionMaker(); 로 D에 관한게 남아 있음...

UserDao의 클라이언트에서  UserDao를 사용하기 전에, 먼저 UserDao가 어떤 ConnectionMaker의 구현 클래스를 사용할지를 결정하기, 즉 UserDao 오브젝트와 특정 클래스로부터 만들어진 ConnectionMaker 오브젝트 사이에 관계를 설정

UserDao 클래스의 main() 메소드를 UserDaoTest로 분리한다. USerDao의 생성자를 수정해서 클라이언트가 제공하는 ConnectionMaker 오브젝트를 전달 받을수 있도록 파라미터 추가

=> UserDao 와 ConnectionMaker을 분리하고 서로 영향을 주지 않게 됨

개발 폐쇄 원칙 : 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다. UserDao로 예를 들면 DB 연결 방법이라는 기능 확장하는데는 열려 있고 핵심 기능을 구현한 코드는 닫아 놓는다.

개방 폐쇄 원칙은 높은 응집도와 낮은 결합도로도 설명 가능
높은 응집도 : 하나의 모듈, 클래스는 하나의 책임 또는 관심사에 집중,  변화가 일어 날때 해당 모듈에서 변하는 부분이 큼

낮은 결합도 : 책임과 관심사가 다른 오브젝트와 느슨하게 연결 된 형태를 유지, 하나의 오브젝트가 변경될때 관계를 맺고 있는 다른 오브젝트에게 요구가 전파되지 않음

UserDao는 응집도가 높고 ConnectionMaker와 인터페이스를 통해 느슨하게 연결되어 있다.

UserDaoTest-USerDao-ConnectionMaker 구조는 디자인 패턴 시각으로 보면 '전략 패턴'에 해당

전략 패턴은 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리 시킴

1.4 제어의 역전

UserDaoTest는 어떤 ConnectionMaker를 사용할지를 정하는 역할도 떠맡게 됨, 원래는 테스트만 해야할 목적으로 만들어 짐

#팩토리 : 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려줌

UserDao, ConnectionMaker 관련 생성 작업을 DaoFactory로 옮기고, UserDaoTest에서 DaoFactory에 요청해서 미리 만들어진 USerDao 오브젝트를 가져와 사용하게 만든다.
이렇게 하면 UserDaoTest는 USerDao가 어떻게 만들어지는지 어떻게 초기화되어 있는지에 신경쓰지 않고 팩토리로부터 UserDao 오브젝트를 받아다 테스트에만 신경 쓸수 있음

제어의 역전 : 자신이 사용할 오브젝트를 스스로 선택, 생성 하지 않음 , 또 자신도 어떻게 만들어지고 어디서 사용되는지 알수 없음. 모든 제어 권한을 자신이 아닌 다른 대상에게 위임한다.

userDao로 예를들면 추상 UserDao를 상속한 서브 클래스는 GetConnection을 구현, 하지만 이 메소드가 어떻게, 언제 사용할지는 자신도 모른다.
단지 구현만 해놓으면 슈퍼 클래스인 UserDao가 필요할때 호출한다. 즉 제어권을 상위 템플릿에 넘김
UserDao와 DaoFactory에도 제어의 역전이 적용되어 있음, 원래 ConnectionMaker오브젝트 만드는 제어권은 UserDao에 있었는데 DaoFactory로 옮김

1.5 스프링의 IoC
#빈 : 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트, 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트

#빈 팩토리 : 빈의 생성과 관계설정 같은 제어를 담당 
보통은 애플리케이션 컨텍스트를 사용

 DaoFactory를 설정정보로 만들기
@Configuration을 써서 오브젝트 설정을 담당하는 클래스라고 인식 시킨다.
오브젝트를 만들어 주는 메소드에는 @Bean이라는 애노테이션 붙여주기
ApplicationContext의 getBean()이라는 메소드를 이용해 bean 으로 등록한 오브젝트 가져오기

오브젝트 팩토리에 대응되는 것이 스프링 애플리케이션 컨텍스트다. 그리고 스프링에서는 이 어플리케이션 컨텍스트를 IoC컨테이너라고 부름
어플리케이션 컨텍스트는 IoC를 적용해서 관리할 모든 오브젝트에 대한 생성과 관계설정을 담당

1.6 싱글톤 레지스트리와 오브젝트 스코프

DaoFactory를 직접 사용하는 것과 Configuration 애노테이션을 추가해서 어플리케이션 컨텍스트를 통해 사용하는것 차이
DaoFactory에서 userDao를 호출할때는 new 로 새로운 오브젝트를 생성한다.
하지만 gean으로 등록하고 DaoFactory의 UserDao를 여러개 호출하면 동일한 오브젝트를 호출하는것이다.

스프링은 기본적으로 내부 생성 빈 오브젝트를 싱글톤으로 만듬, 또한 어플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레즈스트리임
만약 싱글톤이 아니면 수만건의 요청이 생길때마다 오브젝트를 새로 만들어야 하고 그것이 부하로 이어짐

#싱글톤 패턴 : 어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수, 즉 하나만 존재하도록 강제하는 패턴

싱글톤은 자신만이 자기 오브젝트를 만들도록 제한하기에 private 생성자를 가지고 상속 불가하다. 또한 만들어 지는 방식이 제한적이기 때문에 테스트에 한계
스프링은 싱글톤 오브젝트를 싱글톤 레지스트리로 관리하는데 private이 아닌 평범한 자바 클래스를 싱글톤으로 활용하게 해준다. public 사용 가능
따라서 테스트 환경에서 자유롭게 오브젝트를 만들수 있음

싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해 사용할 수 있는데, 다중 사용자의 요청을 한꺼번에 싱글톤에 처리한다면 데이터들이 엉망이 될수 있다.
싱글톤은 인스턴스 필드의 값을 변경하고 유지하는 방식으로 만들지 않음 
개별적으로 바뀌는 정보는 로컬 변수로 정의하거나, 파라미터로 주고받으면서 사용하게 해야 한다.
읽기 전용의 내용들만 싱글톤으로 처리하자.

1.7 의존관계 주입(DI)

의존관계란? B가 변하면 A에 영향을 미칠때, 예를들면 B의 기능이 추가되거나 변경될때 A로 영향이 전달
A가 B를 호출할때 B가 변하면 A에 영향이 간다.
이럴때 A가 B에 의존하고 있다.
UserDao가 ConnectionMaker 인터페이스에 의존하고 있음
하지만 DConnectionMaker를 바꿔도 USerDao에 영향을 미치지 않음 즉 인터페이스로 결합도를 낮춰 줄수 있음

프로그램 시작되고 UserDao 오브젝트가 만들어지고 나서 런타임시에 의존관계를 맺는 대상을 의존 오브젝트라 한다.
의존 관계 주입은 의존 오브젝트와 그것을 사용할 주체를 런타임시에 연결해 주는 작업이다.

의존관계는 세가지 조건 충족하는 작업임
1. 클래스 모델이나 코드에는 의존관계가 드러나지 않음, 그러기 위해서는 인터페이스에만 의존하고 있어야함
2. 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정
3. 의존관계는 오브젝트에 대한 레퍼런스를 외부에서 주입해서 만들어짐

의존관계 주입의 핵심은 설계 시점에 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제 3의 존재가 있음
DaoFactory가 런타임 시점에 UserDao가 사용할 ConnectionMaker 타입의 오브젝트를 결정하고 이를 생성한 후에 UserDao의 생성자 파라미터로 주입에서 UserDao가 DConnectionMaker의 오브젝트와 의존관계 맺음

장점 : 코드에는 의존관계가 나타나지 않고, 인터페이스를 통해 결합도가 낮은 코드를 만드므로, 다른 책임을 가진 사용 의존관계에 있는 대상이 바뀌거나 변경되어도
자신은 영향 받지 않으며 변경을 통한 다양한 확장 방법에는 자유롭다.

의존관계 주입을 위해 생성자를 통한 주입도 가능하고 메소드를 이용한 주입도 가능하다. setter나 set메소드를 이용해서!
DI 받을 오브젝트의 타입 이름을 따서 만드는 것이 무난하다. setConnectionMaker처럼

1.8 xml을 이용한 설정

DI를 위한 오브젝트 의존 관계 설정을 xml을 이용해서도 만들수 있다.



